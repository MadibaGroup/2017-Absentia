% !TEX root = ../main.tex


% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
% = = = Intro 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\section{Introduction}

Consider the traditional multi-party computational setting with a twist: Alice and Bob each have some data, they would like to know the output from running an agreed-upon function on their data, each does not want the other (or anyone else) to learn their data, and they want to simply submit their data (\eg encrypted) to a trustworthy system and come back later for the result. They are willing to pay for this service and understand that, in the worst case of massive collusion between the operators of this service (called trustees), their inputs may be exposed but the result will always be correct.

We assume the reader is familiar with blockchain technology, Ethereum, and smart contracts or decentralized apps (DApps). Can these technologies help? In theory? In practice? We seek to answer this question through direct experimentation. The abstract above builds the argument for why blockchain can help: (1) it provides a integral point of coordination where trustees can post and track progress on the evaluation; (2) it provides an in-band solution for paying the trustees (in either a cryptocurrency like ETH or in a stablecoin pegged to the value of governmental currency like the USD) in a way that is contingent on their performance; and (3) it can serve as the public verifier and can reject any protocol proof that is not correct. When Alice and Bob retrieve the result (whether in plaintext or individually encrypted under their keys), they know it must be correct, otherwise it would not be there waiting for them.

Our experiments show that while in theory the idea is sound and we are able to successfully perform a secure function evaluation of a single logic gate (NAND gate) on Ethereum, the costs today are too prohibitive for it to be considered practical. We then turn to so-called layer-2 solutions and show that Arbitrum (an optimist roll-up that is based on the same trustee model we are already using~\cite{KGCWF18} can make Absentia substantially more practical (with room for further improvement).
 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
% = = = Design Decisions 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 
\subsection{Key design decisions}

Note that we use the term secure function evaluation (SFE) to describe the stateless, one-shot evaluation that Absentia provides; and reserve the term multiparty computation (MPC) for a more setting where stateful computations might be performed over time.

\paragraph{Design decision: Trustee model.} In keeping with our priority for a submit-and-go protocol, someone has to perform the actual evaluation of the function on the inputs. We call these entities \emph{trustees}. We assume the number of trustees ($n$) can be chosen independently of the number of inputs. In Absentia, we simply our implementation to only support robustness in the case that all trustees ($n$-out-of-$n$) participate, however this could modified to allow the protocol to proceed if only a threshold ($t$ out of $n$ for some $t<n/2$) of trustees participate (this, however, also reduces the number of trustees that need to collude to break the privacy, and potentially correctness, of the protocol).  

The remaining question is how can Alice and Bob find trustees they assume will not collude? We have several suggestions: (1) it could be based on personal connections; (2) perhaps commercial entities would emerge with either pre-established reputations or earn their reputation over time (similar to oracle providers) and through legally enforceable terms of service; or (3) trustees could be picked at random from a large set of trustees. While (3) may not sound convincing, it is essentially same threat model as the anonymous web-browsing tool Tor which is trusted by vulnerable users (perhaps Tor also uses flavours of (1) via its the EntryGuard program). 

\paragraph{Design decision: Ethereum.} While we are not the first to explore multi-party computation and its relationship to blockchain (see Section~\ref{sec:lit}), we believe we are the first to implement an MPC protocol on a public, commonly used blockchain; namely, Ethereum. The first research question we is whether MPC is even feasible on Ethereum, given the heavy cryptography it uses. Our paper establishes a benchmark that we hope to see improved through future research. Ethereum itself has scheduled scalability plans including Ethereum 2.0 (more transactions per second), and a lot of community resources are also being spent examining and implementing \emph{layer 2} solutions that move blockchain functionality off of the main chain without sacrificing many of its security benefits. Technologies include \emph{state channels}, \emph{sidechains}, and \emph{roll-ups}~\cite{GMR+20}. To experiment with these technologies, we also deploy and benchmark critical components of Absentia on Arbitrum~\cite{KGCWF18}, a recently proposed system for optimistic roll-ups (describe more in Section~\ref{sec:arb}). We now turn to another avenue for improvement, using state-of-the-art MPC protocols.

\paragraph{Design decision: Mix and match.} Starting with Yao in 1982~\cite{Yao82}, the question of how to securely evaluate a general function, when inputs are held by multiple people, has generated a rich body of literature in cryptography. In choosing an SFE/MPC protocol for the basis of Absentia, we looked for one with the following properties:

\begin{enumerate}
\item \textbf{Trustee model.} As justified above, we seek an MPC/SFE protocol that lets the input holders (\eg Alice and Bob) offload their inputs to a set of non-colluding trustees for evaluation. 
\item \textbf{Publicly verifiable} (aka publicly auditable or universally verifiable). Many MPC/SFE protocols are in the semi-honest (\ie honest-but-curious) model. Some are resilient to covert or malicious adversaries. We require that not only can adversarial behaviour  be detected by the participates in the protocol, but that it can be detected by anyone (\ie the public). This allows (a) Alice and Bob to offload the computational work to the trustees and still ensure the output is correct, even if they did not directly participate, and (b) Alice and Bob can go further and offload the verification itself to someone they trust---the Ethereum network in this case.
\item \textbf{Identifiable aborts.} If the protocol does not reach completion, anyone can establish which trustee aborted.
\item \textbf{Elliptic curve operations.} While Ethereum can in theory implement different types of cryptography (RSA groups, integer-based discrete logarithms groups, lattices, \etc), it has native support for its own cryptographic operations (ECDSA signatures) on the elliptic curve \texttt{secp256k1}. For easy of implementation, we prefer a SFE/MPC with the same cryptographic setting. 
\item \textbf{Circuit type.} When the function to be evaluated is represented as a circuit, the circuit could be based on logic gates (\ie NAND gates) or arithmatic operations (\eg additions and multiplications in a modular group). We are indifferent to this design parameter.
\end{enumerate}

One SPF protocol to meet our purposes is Mix and Match~\cite{JJ00} and we chose it based on our familiarity with it. We are also aware that the state-of-the-art MPC protocols are based on a different paradigm---based on \emph{Beaver triples}~\cite{beaver1997commodity}---initiated by the SPDZ protocol~\cite{damgaard2012multiparty,damgaard2013practical} with many followups (HighGear is a recent example~\cite{keller2018overdrive}). While SPDZ uses lattice-based somewhat homomorphic encryption (SME), this is during a pre-computation phase and Absentia (for now) assumes all pre-computation has been validated. SPDZ also appears amenable to a trustee model and one paper explores a publicly verifiable variant~\cite{baum2014publicly}, however since the authors do not compare themselves to Mix and Match, it would be a complete research project to determine if it is indeed faster. We note that it is not obviously categorically faster---for example, by not requiring public key operations at all: the publicly verifiable variant uses Pedersen commitments extensively.  

We are not aware of an explicit \emph{proof} that Mix and Match is publicly verifiable, however every step of the protocol is covered by a trustee issuing a non-interactive zero knowledge proof and it is later assumed to be by the authors in their auction application~\cite{JJ00}. Stated a different way, it appears that even when all trustees fully collude, trustees can only break privacy (and not integrity) with the exception of one sub-protocol, as noted by the authors~\cite{JJ00}, called the \emph{plaintext equality test} (PET). Despite the caveat, many have used the PET protocol as if it is publicly verifiable (some making justifications based on statistical arguments). Recently it was shown these statistical arguments are not sufficient, but the PET protocol can be made verifiable, even when \emph{all} trustees collude, with a simple additional check on the final output~\cite{mcmurtry2020test}.


\section{Preliminaries}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
% = = = Related Work
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\subsection{Related work}
\label{sec:lit}

The blockchain literature has explored SFE and MPC in several regards. Perhaps the closest to Absentia is Enigma~\cite{zyskind2015decentralizing} which offers stateful MPC as a service. The original academic proposal utilizes a custom blockchain. Now as a commercial project, the emphasis is on providing generic smart contracts with privacy. Engima runs on a Cosmos/Tendermint-based chain, which an Ethereum bridge contract that allows swapping crypto-assets. Absentia is different in the following regards: (1) users provide the circuit they want evaluated, (2) Absentia does not use trusted execution environments (TEE), and (3) we benchmark running natively on Ethereum. Like Enigma, Hawk also provides a privacy wrapper for contracts~\cite{kosba2016hawk}. It is based on succinct zero knowledge and fair MPC is described as an application of Hawk but not implemented.  

%HoneybadgerMPC~\cite{lu2019honeybadgermpc} uses a consensus algorithm to  ???

%~\cite{kiayias2016fair}

The literature has also explored moving computation off-chain while not losing privacy or correctness, however from the perspective a single entity's secret data (\ie verifiable computing as opposed to SFE/MPC). Examples include Zexe~\cite{bowe2020zexe}, ZkVM~\cite{zkvm}, and Raziel~\cite{sanchez2018raziel}. Another research direction, initiated by Andrychowicz \etal~\cite{andrychowicz2014secure}, explores how blockchain technologies can support an off-chain MPC to provide fairness. By contrast, Absentia is performing the SFE on the blockchain. Closely related to SFE/MPC are zero knowledge proofs, whose uses in blockchain are now too prolific to adequately summerize here.

The blockchain literature has explored SFE and MPC in several regards. Enigma~\cite{zyskind2015enigma}, perhaps the closest to Absentia, offers stateful MPC as a service. The academic proposal was for its own blockchain and, now as a commercial project, the emphasis is more on providing generic smart contracts with privacy. While it does not run on Ethereum, a bridge contract is available to allow token transfers to their Cosmos/Tendermint-based chain. Absentia is different in the following regards: (1) users provide the circuit they want evaluated, (2) Absentia does not use trusted execution environments (TEE), and (3) we benchmark running natively on Ethereum. Like Enigma, Hawk also provides a privacy wrapper but is based on succinct zero knowledge~\cite{kosba2016hawk}. Fair MPC is described as an application of Hawk but not implemented.  

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
% = = = Mix and Match 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 


\subsection{Background}

We provide a basic overview of the Mix and Match protocol for secure function evaluation (SFE), while referring the reader to the original paper for the full details~\cite{JJ00}. Mix and Match uses a partially homomorphic encryption scheme; we instantiate it with the additive exponential Elgamal~\cite{CGS97}. We implement it over the elliptic curve \texttt{secp256k1} which is used natively by Ethereum (this results in gas savings).

\paragraph{Mix and Match: Pre-computation.} 

In a pre-computation stage, the following tasks are completed. First, a set of $n$ trustees, identified by public keys, are chosen. A threshold of trustees needed to complete the protocol can also be chosen, however we implement the simplest case: 2-out-of-2 (we call this \emph{distributed} as opposed to \emph{threshold}). Next, the trustees use a distributed key generation (DKG) protocol for creating $n$ shares of the decryption key, one for each trustee, as well as a single joint public key. Exponential Elgamal supports DKG and threshold decryption~\cite{Ped91a}.

In Mix and Match, a circuit of the function to be evaluated is produced using multi-input and multi-output lookup tables. We evaluate a single binary NAND gate (a universal gate that can create any circuit) which corresponds to a lookup table with two binary inputs (one from Alice and one from Bob) and a single binary output. During a pre-computation stage, the circuit for the function is established as a sequence of lookup tables (the output from one table can be used as an input to another). Each element of each lookup table is individually encrypted under the trustees' public key (we denote an encryption of $x$ as $\EncB{x}$):

\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  A			& 	B			& 	Out   			\\ \hline
  $\EncB{0}$ 	&	$\EncB{0}$ 	& 	$\EncB{1}$ 	\\ \hline
  $\EncB{1}$ 	&	$\EncB{0}$ 	&  	$\EncB{1}$ 	\\ \hline
  $\EncB{0}$ 	&	$\EncB{1}$ 	& 	$\EncB{1}$ 	\\ \hline
  $\EncB{1}$ 	&	$\EncB{1}$ 	&  	$\EncB{0}$ 	\\ \hline
\end{tabular}
\end{center}

The encrypted table is then permuted row-wise. Each trustee mixes the rows, rerandomizes each ciphertext, and proves in zero knowledge that the result is correct: 

\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  A			& 	B			& 	Out   			\\ \hline
  $\EncB{0}$ 	&	$\EncB{1}$ 	& 	$\EncB{1}$ 	\\ \hline
  $\EncB{1}$ 	&	$\EncB{0}$ 	&  	$\EncB{1}$ 	\\ \hline
  $\EncB{1}$ 	&	$\EncB{1}$ 	&  	$\EncB{0}$ 	\\ \hline
  $\EncB{0}$ 	&	$\EncB{0}$ 	& 	$\EncB{1}$ 	\\ \hline
\end{tabular}
\end{center}

Complete circuits of such tables can be pre-computed by the trustees before Alice and Bob provide their inputs. Practically speaking, if sets of trustees were established, they could prepare circuits for commonly requested functions and post them publicly. When Alice and Bob decide to do an MPC, they can choose the pre-computed circuit (produced by a specific set of trustees). For the purposes of this paper, we assume circuits have been pre-computed and verified. In the future we may extend Absentia to accept a circuit and complete set of proofs to verify its correct construction, but for this paper, we concentrate on building a verifier for the online phase.

\paragraph{Plaintext Equality Test (PET).} Let $\tuple{\EncB{a},\EncB{b}}$ denote two exponential Elgamal ciphertexts; encryptions of $a$ and $b$ respectively. The trustees will first compute $\EncB{z}=\EncB{a-b}$ using the additively homomorphic property. If the values are the same, $z=0$; otherwise $z\neq 0$. Each trustee will choose a random $r_i\neq0$, compute $\EncB{z_i}=\EncB{r_i*z_{i-1}}$ and prove correctness in zero knowledge. The resultant $\EncB{\hat{z}}=\EncB{\prod r_i*z}$ will still be $\EncB{0}$ when $a=b$ and will encrypt a randomly distributed non-zero integer otherwise. (The original proposal~\cite{JJ00} lets each trustee blind without using the result from the previous trustee---this adds asynchronicity but requires a critical security correction~\cite{mcmurtry2020test}). In the final step, the trustees decrypt and reveal $\hat{z}$.

\paragraph{Mix and Match: Online phase.} The trustees can begin with Alice's input $\EncB{a}$ and they compute a PET between $\EncB{a}$ and ciphertext in the column corresponding to Alice's input. They do the same for Bob. They locate the row that returns true for every input column. The output(s) of this row can then be (1) transferred as an input to the next gate, (2) decrypted publicly if it is a final output, or (3) proxy re-encrypted for Alice (and/or Bob) --- meaning it is obliviously and verifiably changed by the trustees from an encryption under the trustees' joint public key to an encryption under Alice's. For simplicity in Absentia, we implement (2). We illustrate for the previous example and $a=1$ and $b=0$:

\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  A			& 	B			& 	Out   			\\ \hline
  $\mathsf{PET}(\EncB{a},\EncB{0}) = \mathtt{F}$ 	&	$\mathsf{PET}(\EncB{b},\EncB{1}) = \mathtt{F}$ 	& 	 		\\ \hline
  $\mathsf{PET}(\EncB{a},\EncB{1}) = \mathtt{T}$ 	&	$\mathsf{PET}(\EncB{b},\EncB{0}) = \mathtt{T}$ 	&  $\EncB{1}$  	\\ \hline
  $\mathsf{PET}(\EncB{a},\EncB{1}) = \mathtt{T}$ 	&	$\mathsf{PET}(\EncB{b},\EncB{1}) = \mathtt{F}$ 	&  	 		\\ \hline
  $\mathsf{PET}(\EncB{a},\EncB{0}) = \mathtt{F}$ 	&	$\mathsf{PET}(\EncB{b},\EncB{0}) = \mathtt{T}$ 	& 	 		\\ \hline
\end{tabular}
\end{center}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
% = = = Absentia on Ethereum 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\section{Absentia: system design}
\label{sec:system}

\begin{figure}[t]
	\includegraphics[width=1\textwidth]{figures/absentia.pdf}
	\caption{System overview}
	\centering
	\label{fig:system}
\end{figure}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\paragraph{High level flow.} Figure 1. Participants. What they do. Emphasize it just verification and not actual computation. Relate it to Mix and Match as explained above. 

The system is composed of a smart contract, called XXX, and a sub-module called XXX.  two smart contracts. Figure~\ref{fig:system} shows the interaction between the participants and the DApps. At the beginning of the protocol, Alice and Bob deposit enough funds which will be transferred to the trustees at the end of the protocol. They can deposit money any time they want during the protocol. They also load their ciphertexts. 

 Trustee 1 is designated as the manager -> say more.

Trustee 1 is responsible for creating the PET contracts by calling create row function and loading the output values for each row at the beginning of the protocol. For each PET, Trustee 1 performs the subtraction. Again for each PET, both Trustee 1 and Trustee 2 proves in zero knowledge that the randomization of the subtraction result is correct and the partial decryption is done correctly. Trustee 1 fully decrypts the result of the subtraction at the end of each PET. After 8 PETs are performed, Trustee 1 finds the matching row and the corresponding encrypted value. Trustee 1 and Trustee 2 partially decrypt and prove in zero knowledge again to obtain the decrypted result.

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\paragraph{Payments.} What we do for now. Pointer to discussion section for other options. 

Alice and Bob can withdraw all the funds they deposited before the protocol starts, at the end of the protocol or after a certain amount of time passes. They can also transfer themselves the extra funds they have deposited, any time during the execution of the protocol, as long as there are enough funds left to pay the trustees. Funds are transferred tot the trustees at the end of the protocol, after thay determined the final output. In another possible design, trustees can be paid at each step they performed towards reaching the final output.

% ~\footnote{\url{https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol}} is used to prevent reentrancy attack.

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\paragraph{Code layout.} Details of testing platform (solidity, \etc). Link to Github. Mathematica is doing what? Solidity is doing what? On Ethereum: Library (why?). PET as module. Factory design (why?) 

a library to perform elliptic curve operations. 

~\textcolor{red}{TO-DO:}
The system is first implemented in Mathematica to have test vectors for the Solidity implementation. For our example, we used AND gate and there are two trustees that perform the computations. One of the trustees is designated as the manager who is responsible for creating and encrypting the table and finding the matching value at the end of the protocol.

The elliptic curve library is taken from~\footnote{\url{https://github.com/orbs-network/elliptic-curve-solidity/blob/master/ECops.sol}}. As multiplication is the most expensive function, we do not perform the multiplication itself in the smart contract. Instead, we use the trick explained in~\footnote{\url{https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384}}. Multiplication is preformed off-chain and the function $ecmulVerify$ takes the multiplicand, scalar and the product as input and verifies that the multiplication is done correctly.

Factory design pattern is used to realize the system. Mix and match contract creates instances of PET contract for each cell in the NAND table , so that Alice and Bob's inputs are compared against related cells.

Depositing values to each PET vs depositing once

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\subsection{Measurements}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\paragraph{Testing platform.} Truffle. Private network. Custom settings (forward pointer for reason to below). 

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\input{tables/codesize.tex}

\paragraph{Code size.} Various sizes. Limits of Ethereum. Consequences (changing limit in truffle). Explain table.

The code size for the mixmatch contract is outlined in Table~\ref{tab:codesize}. Contract size limit is 24KB according to EIP170. As our main contract is over this limit, we ran our test in Truffle by allowing unlimited contract size.


% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\input{tables/gascosts.tex} 

\input{tables/gascosts2.tex}

\input{tables/scale.tex}

\paragraph{Gas costs.} Explain Tables (per function, per participant). Clarify what exactly T1 does. Details of gas to USD.

Table~\ref{tab:gascost} illustrates the cost of deployment of all contracts needed in Absentia and the functions in the two main contracts. The gas costs are recorded using local blockhain provided by Truffle. For the tests run in Truffle the gas limit is set to $12414689$. To calculate the gas costs, we used 1 gas = 87 Gwei as recorded on Dec 01, 2020~\footnote{https://etherscan.io/chart/gasprice}. The function Create Row creates two instances of PET contract and it is the most expensive function compared to other functions. Trustee 1 has to perform more operations than the other participants as the manager (see Table~\ref{tab:participantcost}).

Table~\ref{tab:settings} compares how the gas costs differ at different settings compared to our main setting, where two Trustees evaluate one gate. When we want to evaluate two circuits, Alice and Bob still performs the same number of transactions, as they have to submit their ciphertexts once. The work for Trustee 1 and Trustee 2 is doubled, as they have to evaluate two gates. The cost for the setting, where 3 Trustees are used to evaluate one gate is closer to the cost of the main setting, as the extra cost from Trustee 3 will be the same as Trustee 2.


% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
% = = = Arbitrum 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\section{Absentia on Layer 2 }
\label{sec:arb}

\subsection{Roll-ups}

A loose collection of technologies, called \emph{Layer 2} solutions, have been proposed to address certain shortcomings of operating directly on Ethereum (\emph{Layer 1}) or other blockchains~\cite{GMR+20}. These solutions generally strive for one or more of the following: reducing transaction latency, increasing transaction throughput, or reducing gas costs. In the case of Absentia, reducing gas costs is paramount. However Layer 2 solutions can also change the threat model; for Absentia, we require that Alice and Bob can trust the final output without having to verify any proofs themselves. 

The most appropriate layer 2 technology for our requirements is called a \emph{roll-up} which targets gas costs. In Ethereum, every transaction is executed (and thus validated) by every Ethereum node. In a roll-up, transactions are executed by off-chain nodes called \emph{validators}. Validators try to convince the Ethereum network that the result of the transaction execution (\ie the state change of the EVM) is correct without the Ethereum nodes having to execute it. 

Since Ethereum nodes cannot just ignore the Ethereum protocol's specifications for how to validate transactions, the roll-up cannot be implemented on Layer 1. Rather it is implemented inside its own DApp (Layer 2). This Layer 2 DApp is effectively a container, operating by its own custom consensus rules, for DApps that want roll-up functionality. The tradeoff is they are isolated from regular L1 DApps without some additional protocols (\eg interoperability support for currency/token transfers and external function calls). For Abstentia, we do not require interoperability with L1 other than having a payment mechanism.

There are at least two ways to convince on-chain participants that an off-chain computation was performed correctly. The first is to prove it with a succinct proof. SNARKS are one proof-type for general computations that are more efficient to verify than performing the computation itself. The second (an \emph{optimistic rollup}) is to have a validator assert the result and then allow for anyone to dispute it. Resolving disputes is always possible by performing the computation itself but disputes can be settled in a more succinct way (see \cite{KGCWF18}). If Alice demonstrates that a validator is wrong, the validator is financially punished and Alice is rewarded. Such validators do less work than Ethereum nodes (and validators that have to produce SNARKS)---therefore, optimistic rollups enable substantially lower gas costs.

\subsection{Arbitrum}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/arbitrum.pdf}
	\caption{Overview of Arbitrum transaction submission.}
	\label{fig:arbsys}
\end{figure}

Arbitrum is Layer 2 solution proposed in a \textit{USENIX Security} paper~\cite{KGCWF18} and now maintained as a commercial project by Offchain Labs. Currently, they operate an optimistic rollup on Ethereum. Instead of operating all Arbitrum contracts (called \emph{ArbOS}) in a container DApp on Ethereum, ArbOS instead operates as a side-chain. A  \emph{bridge contract} on Ethereum serves as an interface between Ethereum and Arbitrum. Figure~\ref{fig:arbsys} shows how function calls work on Arbitrum. A user initiates a transaction on Ethereum to the Bridge Contract with the instruction to deploy a contract or run a function, along with all the data required for Arbitrum to perform this transaction. A validator sees new transactions in the inbox of the bridge, executes one and asserts the result to ArbOS. After a dispute period, the transaction is consider finalized. Periodically, the entire state of ArbOS is committed back to Ethereum.  

\subsection{Absentia on Arbitrum}

\paragraph{Testing platform.} Arbitrum runs a testnet with a bridge on Ethereum's Kovan testnet. As mentioned above, Absentia is too large to deploy (as a factory contract) within Ethereum's contract size limit. To experiment with Arbitrum, we implement only the PET sub-module as a standalone contract. We use Truffle. Instead of sending transactions to the Arbitrum bridge (as in Figure~\ref{fig:arbsys}), Arbitrum allows transactions to be sent to relay server (called an \emph{Aggregator}) which will batch all pending transactions together as a single Kovan transaction to the bridge (and pay the gas). However we report the measurements as if the participants were sending the transactions themselves.

\input{tables/arbgas.tex}

\paragraph{Gas costs.} Explain and discuss Table. How much does one PET cost in total for T1? For T2? What about with arbitrum (just paying gas and assuming arbgas is free)? What is the savings in terms of a percentage?






% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
% = = = Discussion 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\section{Discussion}

\begin{itemize}
\item Payments: fancier, contingent on who aborts, timeliness, \etc
\item Pre-comp: validate it , have pre-built and validated circuits, \etc
\item Implementation improvements: factory design and contract size
\item Proxy re-encryption instead of decryption
\item what else?
\end{itemize}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
% = = = Conclusions
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

\section{Concluding Remarks}
