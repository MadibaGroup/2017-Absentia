% !TEX root = ../main.tex
\section{Introductory Remarks}

Consider the now classic Millionaire's problem where Alice and Bob both have a secret value that represents their wealth, $\EncB{a}$ and $\EncB{b}$ respectively. They wish to learn the value $z=\mathsf{Max}(a,b)$ without disclosing $a$ or $b$ to each other. In general, $\mathsf{Max}$ could be any deterministic function that is computable in reasonable time and the inputs to the function might include more than two private inputs. 

The general approach of the literature is to have Alice and Bob run a joint protocol on their private inputs that requires them to coordinate and complete a few rounds of communication.

Our goal in this paper is to explore a model where Alice can leave an encryption of $a$, $\EncB{a}$, in a public place and Bob can leave $\EncB{b}$. We defer a discussion of what encryption key is used. Later they can return to receive $\EncB{z}_a$ and $\EncB{z}_b$ where this is $z$ encrypted under their individual keys. When they fetch this value, they are confident $z$ is correct.

Between leaving their private inputs and retrieving the output, the computation itself is performed --- not by Alice and Bob, but by some workers they have outsourced the computation to. These workers should not learn $a$, $b$, $z$ or any intermediary values of the computation under some reasonable assumption (we rely on non-collusion between them). 


\subsection{Scope}

Threat model: secret inputs, correct computation


No secrets, trust computation
- cloud computing problem

No secrets, no trust
- verifiable computing

one secret, no trust
- verifiable computing

two or more secrets, trust
- honest but curious model - two GC, three+ MPC (based on secret sharing)

two or more secrets, no trust
- malicious model - same as above, plus mix and match 

public verifiable
- mix and match 

One secret, no trust, public verifiable 
FHE (more than one secret - who has decryption key?) 
Joint decryption at the end for MPC

Functional encryption
- seems different

\subsection{Deployability}

Multi users with secrets

Users to not have to be online at the same time (excludes GC, MPC, etc) - one round of communication to submit inputs

they will have to submit somehow: minimize what they need to know at submission time. encrypt it but need to know a key - to know key, need to know computational trustees

minimize privacy assumptions around submission - submit to a public broadcast channel (as opposed to private channels with trustees) 

at the end, they have to receive the output - public channel, asynchronous, one round of communication, 

at the end, they have to check a proof - great to delegate proof to others so they don't have to check (public verifiability vs normal malicious model)

\subsection{Mix and Match}

There is only one SFE protocol that seems to work this way out of the box: Mix and Match.

Users, Trustees, Miners

\subsection{Trustees}

Why did mix and match fail? Who are the trustees going to be? IBM, Microsoft, Google in 2-out-of-3 is great for papers but not realistic 

Anyone can be with some human verification on top - Tor model 

Plus, unlike Tor, we can pay them

\subsection{Coordination}

Bulletin board: append-only (immutable) broadcast (non-equivocating) - blockchain
Payments: blockchain
Verification for free: blockchain

Which blockchain? Ethereum
Other related projects: Enigma

\section{Future Work}

Applying this to one-time programs and short-lived signatures

Ephemeral storage

Sending a black box

 

